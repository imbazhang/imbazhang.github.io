[{"title":"Contest-172-E","date":"2019-11-26T06:24:16.000Z","path":"2019/11/26/Contest172E/","text":"正好很长时间没管这边了，趁这个机会水一篇 题意1e3*1e3 的迷宫里面挖宝，有两种方式前进：一次前进一步或者一次前进 r步。求最早到达目标点的 index ，可以存在多解。 思路很简单，直接BFS搜就行了。EOJ连不上判题服务器，但是样例测了没问题。 UPDATE：出锅了，待修。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#pragma clang diagnostic push#pragma ide diagnostic ignored \"cert-err34-c\"#pragma ide diagnostic ignored \"hicpp-signed-bitwise\"#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, r;typedef pair&lt;int, int&gt; pii;int G[1005][1005];unsigned int now = 0, cnt = 0;bool vis[1005][1005], flag = false;queue&lt;pair&lt;pii, int&gt; &gt; q[2]; // NOLINT(cert-err58-cpp)pii tar;queue&lt;int&gt; ans;queue&lt;pii&gt; rec;pii dirc[4] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;void bfs() &#123; while (!q[now].empty()) &#123; pii sta = q[now].front().first; if (sta == tar) &#123; flag = true; ans.push(q[now].front().second); q[now].pop(); continue; &#125; for (auto &amp;i : dirc) &#123; if (!vis[sta.first + i.first][sta.second + i.second]) &#123; if (G[sta.first + i.first][sta.second + i.second] == 0 || G[sta.first + i.first][sta.second + i.second] == -2) &#123; q[now ^ 1].push( make_pair(make_pair(sta.first + i.first, sta.second + i.second), q[now].front().second)); rec.push(make_pair(sta.first + i.first, sta.second + i.second)); &#125; &#125; &#125; if (r != 1) &#123; for (auto &amp;i : dirc) &#123; bool tag = false; for (int i1 = 1; i1 &lt;= r; i1++) &#123; if (G[sta.first + i1 * i.first][sta.second + i1 * i.second] == -1) &#123; if (!vis[sta.first + (i1 - 1) * i.first][sta.second + (i1 - 1) * i.second] &amp;&amp; i1 != 2) &#123; q[now ^ 1].push(make_pair(make_pair(sta.first + (i1 - 1) * i.first, sta.second + (i1 - 1) * i.second), q[now].front().second));// cout &lt;&lt; \"insert\" &lt;&lt; sta.first + (i1 - 1) * i.first &lt;&lt; ' ' &lt;&lt; sta.second + (i1 - 1) * i.second &lt;&lt; ' ' &lt;&lt; q[now].front().second &lt;&lt; endl; rec.push(make_pair(sta.first + (i1 - 1) * i.first, sta.second + (i1 - 1) * i.second)); &#125; tag = true; break; &#125; &#125; if (!tag &amp;&amp; !vis[sta.first + r * i.first][sta.second + r * i.second]) &#123; q[now ^ 1].push(make_pair(make_pair(sta.first + r * i.first, sta.second + r * i.second), q[now].front().second));// cout &lt;&lt; \"insert\" &lt;&lt; sta.first + r * i.first &lt;&lt; ' ' &lt;&lt; sta.second + r * i.second &lt;&lt; ' ' &lt;&lt; q[now].front().second &lt;&lt; endl; rec.push(make_pair(sta.first + r * i.first, sta.second + r * i.second)); &#125; &#125; &#125; q[now].pop(); &#125; if (flag) return; cnt++; now ^= 1; while (!rec.empty()) &#123; vis[rec.front().first][rec.front().second] = true; rec.pop(); &#125; bfs();&#125;void print() &#123; while (!ans.empty()) &#123; printf(\"%d \", ans.front()); ans.pop(); &#125; printf(\"\\n%d\", cnt);&#125;int main() &#123; memset(vis, false, sizeof(vis)); scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;r); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;G[i][j]); if (G[i][j] &gt;= 1) &#123; q[0].push(make_pair(make_pair(i, j), G[i][j])); vis[i][j] = true; &#125; else if (G[i][j] == -2) &#123; tar.first = i; tar.second = j; &#125; else if (G[i][j] == -1) vis[i][j] = true; &#125; &#125;// cout &lt;&lt; tar.first &lt;&lt; ' ' &lt;&lt; tar.second &lt;&lt; endl; bfs(); print(); return 0;&#125;#pragma clang diagnostic pop Clion的自动提示还挺好玩","tags":[{"name":"BFS","slug":"BFS","permalink":"imbazhang.github.io/tags/BFS/"}]},{"title":"随想","date":"2019-10-04T03:52:23.000Z","path":"2019/10/04/随想/","text":"许愿：我喜欢的女孩子能遇到一个她爱的、也爱她的、足够优秀的男生啊。","tags":[]},{"title":"CF1187B Letters Shop","date":"2019-07-01T14:49:15.000Z","path":"2019/07/01/CF_edu57B/","text":"CF1187B Letters Shop ：前缀和 终于水到B难度的题也要来写一写了？ 摸了半个晚上，差点就被等号搞崩了心态。 题面：http://codeforces.com/contest/1187/problem/B 题意：给出一个很长的主串，选取前缀，使得子串能够被前缀表示，要求给出最少选取的前缀位数。 前缀和。26个小写字母进行处理，给出到达每一位时、每个字母出现的最多次数。预处理部分有点烦；问询的串需要处理每个字母出现的次数。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int n, sum[26], s[200005][26], t[200005][26];char line[200005];int main()&#123; scanf(\"%d\", &amp;n); scanf(\"%s\", line+1); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;26;j++) if (j == line[i] -'a') s[i][j] = s[i-1][j]+1; else s[i][j] = s[i-1][j]; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;26;j++) t[i][j] = n + 1; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;26;j++) t[s[i][j]][j] = min(t[s[i][j]][j], i); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", line+1); for (int i=0;i&lt;26;i++) sum[i] = 0; int len = strlen(line+1), ans = 0; for (int i=1;i&lt;=len;i++) sum[line[i] - 'a']++; for (int i=0;i&lt;26;i++) ans = max(ans, t[sum[i]][i]); printf(\"%d\\n\", ans); &#125; return 0;&#125; 闲片： 1.摸鱼比正事干得多 2.因为明天有安排，所以明天咕咕咕预定？ 3.室友开始看统计学的书了，搞得我慌得不行… 4.数学偏科，没了","tags":[{"name":"Prefix","slug":"Prefix","permalink":"imbazhang.github.io/tags/Prefix/"}]},{"title":"ECNU XCPC Training on CF Contest 2:Greedy 个人题解","date":"2019-03-18T14:15:04.000Z","path":"2019/03/18/contest2_greedy/","text":"ECNU XCPC Training on CF Contest 2: Greedy 个人题解总算不是自闭场了【(:з」∠)题面：http://codeforces.com/group/ki6jEDpY8g/contest/240026 场内：四题（C, D, E, H）C.Our Tanya is Crying Out Loud题意给出n, k, A, B 四个数字，要求对 x 通过两种操作：（1）每次将 x 减去1 （2）在 x 可以被 k 整除时，除 k。操作1的花销是A， 操作2的花销是B，求解使得 x 为1的最小花销 思路在不能够整除 k 时，只能减去1；在可以整除 k 时，比较 整除一次的花销 和 每次减1到达 x/k 的花销 AC代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;long long n,k,a,b,f1,f2,ans;int kkk,aaa;int main()&#123; scanf(\"%I64d%I64d%I64d%I64d\",&amp;n,&amp;k,&amp;a,&amp;b); kkk=(b-1)/a+1; //???? if(k==1) &#123; ans=(n-1)*a; printf(\"%I64d\",ans); return 0; &#125; while(n!=1) &#123; if(n%k==0) &#123; f2=n-(n/k); if(f2&gt;=kkk) &#123; n=n/k; ans+=b; &#125; else &#123; n=n/k; ans+=f2*a; &#125; &#125; else &#123; aaa=n/k*k; if(aaa==0) &#123; ans+=(n-1)*a; break; &#125; ans+=a*(n-aaa); n=aaa; &#125; &#125; printf(\"%I64d\",ans);&#125; 注意当数据大的时候，每次减1的开销会T掉【爆了三发】，所以直接找到下一个可以被整除的位置即可。 D. Alarm Clock题意有 n 个闹钟会在不同的时间响起，Vitalya会每熟睡 m 分钟后浅睡 n 分钟，要求关掉最少的闹钟使得在浅睡时间内不会被闹钟叫醒。（每个闹钟的响铃时间为1分钟） 思路（类似《挑战》上的一道例题）为了去掉最少的点，每次都在最后的位置去掉点，这样能够保证去掉的点（可能）使得之后不会被叫醒。 AC代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; int n, m, k, res = 0; int clocks[200010]; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; queue&lt;int&gt; que; for (int i=0;i&lt;n;i++) cin &gt;&gt; clocks[i]; sort(clocks, clocks + n); for (int i=0;i&lt;n;i++) &#123; while (!que.empty()&amp;&amp; clocks[i] - que.front() &gt;= m) que.pop(); if (que.size() &gt;= k - 1) res += 1; else que.push(clocks[i]); &#125; cout &lt;&lt; res; return 0;&#125; 需要注意 clocks[] 的数组大小，如果不直接开到最大的话容易RE E. Find Amir太水了【】，一共 n 个节点，要遍历每个节点，并且不同下标的节点间的花销是$$(i+j) mod (n+1)$$求最小花销。 显然，前半部分和后半部分的节点一一配对就没有花销；两部分间调动的时候只需要配对节点的下一个就使得花销为1。只需要考虑偶数节点可以少走一次。 AC代码12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; if (n%2) cout &lt;&lt; (n/2); else cout &lt;&lt; (n/2) - 1; return 0;&#125; H. Tennis Championship打表大法好！ 题意每个选手只能和与他的比赛次数相差不超过 1 的人比赛，求冠军最多进行比赛场数； 思路倒着想，冠军的场数是 n ,亚军的场次数即为 n-1 ,所以可以倒退到每一个和冠军比赛的人场数都为 x-1 ,其实就是一个斐波那契数列、 【可耻的直接打表了….莫得代码放 场外：A, F","tags":[{"name":"Greedy","slug":"Greedy","permalink":"imbazhang.github.io/tags/Greedy/"}]},{"title":"my_test_site","date":"2019-03-13T11:08:41.000Z","path":"2019/03/13/my-test-site/","text":"把旧的博客拆了重新，在Hexo框架下重新搭了个新的。 目前使用的是 inidgo 主题。 总之还是贯彻摸鱼宗旨，不过确实该有规律的写写东西了。","tags":[]},{"title":"Hello World","date":"2019-03-13T11:03:33.639Z","path":"2019/03/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]